"""
Go Vulnerability Tool - Security vulnerability scanning for Go projects.

This tool analyzes Go projects by examining go.mod and go.sum files to identify
known security vulnerabilities in dependencies and suggests remediation steps.
"""

import os
import re
import time
import json
import subprocess
from typing import Dict, List, Any, Optional
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime

import requests
from packaging import version

from tools.base_tool import BaseTool, ToolResult, ToolMetadata, ToolCapability, AnalysisContext
from utils.logging_config import get_logger

logger = get_logger(__name__)


@dataclass
class GoModule:
    """Represents a Go module dependency."""
    name: str
    version: str
    indirect: bool = False
    
    def __str__(self):
        return f"{self.name}@{self.version}"


@dataclass
class Vulnerability:
    """Represents a security vulnerability."""
    id: str
    summary: str
    details: str
    severity: str
    affected_module: str
    affected_versions: List[str]
    fixed_versions: List[str]
    cve_ids: List[str]
    references: List[str]
    
    @property
    def severity_score(self) -> int:
        """Get numeric severity score for sorting."""
        severity_map = {
            "CRITICAL": 4,
            "HIGH": 3,
            "MEDIUM": 2,
            "MODERATE": 2,
            "LOW": 1,
            "UNKNOWN": 0
        }
        return severity_map.get(self.severity.upper(), 0)


class GoVulnerabilityTool(BaseTool):
    """
    Tool for scanning Go projects for known security vulnerabilities.
    
    This tool analyzes go.mod and go.sum files, checks dependencies against
    vulnerability databases, and provides detailed security reports.
    """
    
    def __init__(self):
        super().__init__()
        
        # Vulnerability database URLs
        self.vuln_db_urls = {
            "go_vulndb": "https://vuln.go.dev/",
            "osv": "https://osv.dev/",
            "github_advisory": "https://api.github.com/advisories"
        }
        
        # Common vulnerable patterns to look for
        self.vulnerable_patterns = [
            r"golang\.org/x/crypto.*v0\.0\.0-20190308221718-c2843e01d9a2",  # Old crypto
            r"github\.com/gin-gonic/gin.*v1\.[0-6]\.",  # Old Gin versions
            r"github\.com/gorilla/websocket.*v1\.[0-4]\.",  # Old WebSocket
        ]
    
    def _create_metadata(self) -> ToolMetadata:
        """Create metadata for the Go vulnerability tool."""
        return ToolMetadata(
            name="go_vulnerability_scanner",
            description="Security vulnerability scanner for Go projects analyzing dependencies in go.mod and go.sum",
            version="1.0.0",
            capabilities=[
                ToolCapability.VULNERABILITY_SCANNING,
                ToolCapability.SECURITY_AUDIT,
                ToolCapability.DEPENDENCY_ANALYSIS
            ],
            supported_languages=["go"],
            required_files=["go.mod"],
            optional_files=["go.sum", "go.work"],
            execution_time_estimate="30 seconds - 1 minute",
            dependencies=["requests", "packaging"]
        )
    
    def validate_context(self, context: AnalysisContext) -> tuple[bool, List[str]]:
        """Validate that the context is suitable for Go vulnerability scanning."""
        errors = []
        
        # Check if repository path exists
        if not context.repository_path or not Path(context.repository_path).exists():
            errors.append("Repository path does not exist or is not provided")
            return False, errors
        
        # Check for go.mod file
        go_mod_path = Path(context.repository_path) / "go.mod"
        if not go_mod_path.exists():
            errors.append("go.mod file not found - this tool requires a Go project")
            return False, errors
        
        # Check if Go is detected in target languages
        if context.target_languages and "go" not in [lang.lower() for lang in context.target_languages]:
            # Still allow, but warn
            logger.warning("Go not detected in target languages, but go.mod found")
        
        # Check if intent is compatible - ONLY activate for security-related intents
        security_intents = ["find_vulnerabilities", "security_audit", "security", "vulnerabilities", "scan_vulnerabilities", "check_security"]
        security_keywords = ["vulnerabilit", "security", "cve", "exploit", "attack", "breach", "audit"]
        
        # Check explicit security intents
        if context.intent in security_intents:
            logger.info(f"Intent '{context.intent}' - activating security analysis")
            return len(errors) == 0, errors
        
        # Check for security keywords in primary intent
        if any(keyword in context.intent.lower() for keyword in security_keywords):
            logger.info(f"Security keyword detected in intent '{context.intent}' - activating security analysis")
            return len(errors) == 0, errors
        
        # Check for security keywords in original context (for multi-intent requests)
        original_context = context.additional_params.get('original_context', '').lower()
        if original_context and any(keyword in original_context for keyword in security_keywords):
            logger.info(f"Security keyword detected in original context - activating security analysis")
            return len(errors) == 0, errors
        
        # For non-security intents, do not activate this tool
        logger.debug(f"Intent '{context.intent}' is not security-related - skipping vulnerability scanning")
        errors.append(f"Tool not suitable for intent '{context.intent}' - requires security-related context")
        return False, errors
    
    async def execute(self, context: AnalysisContext, **kwargs) -> ToolResult:
        """Execute Go vulnerability scanning."""
        start_time = time.time()
        logger.info(f"Starting Go vulnerability scan for {context.repository_url}")
        
        try:
            results = {}
            
            # Step 1: Parse go.mod and go.sum files
            logger.info("Parsing Go module files...")
            modules = self._parse_go_modules(context.repository_path)
            results['modules_analyzed'] = len(modules)
            results['modules'] = [str(m) for m in modules]
            
            # Step 2: Check for known vulnerability patterns
            logger.info("Checking for known vulnerability patterns...")
            pattern_vulnerabilities = self._check_vulnerability_patterns(modules)
            
            # Step 3: Query external vulnerability databases
            logger.info("Querying vulnerability databases...")
            db_vulnerabilities = await self._query_vulnerability_databases(modules)
            
            # Step 4: Run govulncheck if available
            logger.info("Attempting to run govulncheck...")
            govulncheck_results = await self._run_govulncheck(context.repository_path)
            
            # Step 5: Combine and analyze results
            all_vulnerabilities = pattern_vulnerabilities + db_vulnerabilities
            if govulncheck_results:
                all_vulnerabilities.extend(govulncheck_results)
            
            # Remove duplicates and sort by severity
            unique_vulnerabilities = self._deduplicate_vulnerabilities(all_vulnerabilities)
            unique_vulnerabilities.sort(key=lambda v: v.severity_score, reverse=True)
            
            # Step 6: Generate vulnerability report
            vulnerability_report = self._generate_vulnerability_report(
                modules, unique_vulnerabilities, context.repository_path
            )
            
            results.update(vulnerability_report)
            
            execution_time = time.time() - start_time
            
            return ToolResult(
                tool_name=self.metadata.name,
                success=True,
                execution_time=execution_time,
                results=results,
                metadata={
                    "vulnerabilities_found": len(unique_vulnerabilities),
                    "critical_vulnerabilities": len([v for v in unique_vulnerabilities if v.severity.upper() == "CRITICAL"]),
                    "high_vulnerabilities": len([v for v in unique_vulnerabilities if v.severity.upper() == "HIGH"]),
                    "modules_scanned": len(modules)
                }
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"Go vulnerability scan failed: {e}")
            
            return ToolResult(
                tool_name=self.metadata.name,
                success=False,
                execution_time=execution_time,
                results={},
                errors=[str(e)]
            )
    
    def _parse_go_modules(self, repository_path: str) -> List[GoModule]:
        """Parse go.mod and go.sum files to extract module dependencies."""
        modules = []
        
        try:
            go_mod_path = Path(repository_path) / "go.mod"
            
            # Parse go.mod
            with open(go_mod_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extract require block
            in_require_block = False
            for line in content.split('\n'):
                line = line.strip()
                
                if line.startswith('require ('):
                    in_require_block = True
                    continue
                elif line == ')' and in_require_block:
                    in_require_block = False
                    continue
                elif line.startswith('require ') or in_require_block:
                    # Parse requirement line
                    if line.startswith('require '):
                        line = line[8:].strip()  # Remove 'require '
                    
                    if line and not line.startswith('//'):
                        # Handle indirect dependencies
                        indirect = '// indirect' in line
                        line = line.split('//')[0].strip()
                        
                        # Extract module and version
                        parts = line.split()
                        if len(parts) >= 2:
                            module_name = parts[0]
                            module_version = parts[1]
                            
                            modules.append(GoModule(
                                name=module_name,
                                version=module_version,
                                indirect=indirect
                            ))
            
            logger.info(f"Parsed {len(modules)} modules from go.mod")
            
        except Exception as e:
            logger.error(f"Failed to parse go.mod: {e}")
        
        return modules
    
    def _check_vulnerability_patterns(self, modules: List[GoModule]) -> List[Vulnerability]:
        """Check modules against known vulnerability patterns."""
        vulnerabilities = []
        
        try:
            for module in modules:
                module_str = str(module)
                
                # Check against known vulnerable patterns
                for pattern in self.vulnerable_patterns:
                    if re.search(pattern, module_str):
                        vulnerabilities.append(Vulnerability(
                            id=f"PATTERN_{hash(pattern)}",
                            summary=f"Known vulnerable pattern detected in {module.name}",
                            details=f"Module {module.name}@{module.version} matches known vulnerability pattern",
                            severity="HIGH",
                            affected_module=module.name,
                            affected_versions=[module.version],
                            fixed_versions=["latest"],
                            cve_ids=[],
                            references=[]
                        ))
            
        except Exception as e:
            logger.error(f"Failed to check vulnerability patterns: {e}")
        
        return vulnerabilities
    
    async def _query_vulnerability_databases(self, modules: List[GoModule]) -> List[Vulnerability]:
        """Query external vulnerability databases for module vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Query OSV database (simulated - in production would use actual API)
            for module in modules[:10]:  # Limit to first 10 to avoid rate limits
                try:
                    osv_vulns = await self._query_osv_database(module)
                    vulnerabilities.extend(osv_vulns)
                except Exception as e:
                    logger.warning(f"Failed to query OSV for {module.name}: {e}")
                    continue
            
        except Exception as e:
            logger.error(f"Failed to query vulnerability databases: {e}")
        
        return vulnerabilities
    
    async def _query_osv_database(self, module: GoModule) -> List[Vulnerability]:
        """Query OSV database for a specific module."""
        vulnerabilities = []
        
        try:
            # Note: This is a simplified implementation
            # In production, you would use the actual OSV API
            
            # For demo purposes, simulate some vulnerabilities for common modules
            known_vulns = {
                "github.com/gin-gonic/gin": {
                    "id": "GO-2023-1234",
                    "summary": "Path traversal vulnerability in Gin framework",
                    "severity": "MEDIUM",
                    "affected_versions": ["< v1.7.0"],
                    "fixed_versions": ["v1.7.0", "v1.8.0+"]
                },
                "golang.org/x/crypto": {
                    "id": "GO-2023-5678", 
                    "summary": "Weak cryptographic implementation",
                    "severity": "HIGH",
                    "affected_versions": ["< v0.1.0"],
                    "fixed_versions": ["v0.1.0+"]
                },
                "github.com/gorilla/websocket": {
                    "id": "GO-2023-9999",
                    "summary": "WebSocket connection hijacking vulnerability",
                    "severity": "CRITICAL",
                    "affected_versions": ["< v1.5.0"],
                    "fixed_versions": ["v1.5.0+"]
                }
            }
            
            if module.name in known_vulns:
                vuln_info = known_vulns[module.name]
                
                # Check if current version is affected
                affected = True  # Simplified check
                
                if affected:
                    vulnerabilities.append(Vulnerability(
                        id=vuln_info["id"],
                        summary=vuln_info["summary"],
                        details=f"Vulnerability found in {module.name}@{module.version}",
                        severity=vuln_info["severity"],
                        affected_module=module.name,
                        affected_versions=vuln_info["affected_versions"],
                        fixed_versions=vuln_info["fixed_versions"],
                        cve_ids=[],
                        references=[f"https://osv.dev/{vuln_info['id']}"]
                    ))
            
        except Exception as e:
            logger.warning(f"Failed to query OSV for {module.name}: {e}")
        
        return vulnerabilities
    
    async def _run_govulncheck(self, repository_path: str) -> Optional[List[Vulnerability]]:
        """Attempt to run govulncheck tool if available."""
        try:
            # Check if govulncheck is available
            result = subprocess.run(
                ["govulncheck", "-version"],
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',  # Handle encoding errors gracefully
                timeout=10
            )
            
            if result.returncode != 0:
                logger.info("govulncheck not available")
                return None
            
            # Run govulncheck
            result = subprocess.run(
                ["govulncheck", "-json", "./..."],
                cwd=repository_path,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',  # Handle encoding errors gracefully
                timeout=60
            )
            
            if result.returncode == 0:
                # Parse govulncheck output (simplified)
                logger.info("govulncheck completed successfully")
                return []  # Would parse actual results here
            else:
                logger.warning(f"govulncheck failed: {result.stderr}")
                return None
                
        except subprocess.TimeoutExpired:
            logger.warning("govulncheck timed out")
            return None
        except FileNotFoundError:
            logger.info("govulncheck not installed")
            return None
        except UnicodeDecodeError as e:
            logger.warning(f"Unicode decode error in govulncheck output: {e}")
            return None
        except Exception as e:
            logger.warning(f"Failed to run govulncheck: {e}")
            return None
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities based on ID and affected module."""
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            key = (vuln.id, vuln.affected_module)
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    def _generate_vulnerability_report(
        self, 
        modules: List[GoModule], 
        vulnerabilities: List[Vulnerability],
        repository_path: str
    ) -> Dict[str, Any]:
        """Generate comprehensive vulnerability report."""
        
        # Categorize vulnerabilities by severity
        severity_counts = {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0,
            "UNKNOWN": 0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.severity.upper()
            if severity in severity_counts:
                severity_counts[severity] += 1
        
        # Calculate risk score
        risk_score = (
            severity_counts["CRITICAL"] * 10 +
            severity_counts["HIGH"] * 5 +
            severity_counts["MEDIUM"] * 2 +
            severity_counts["LOW"] * 1
        )
        
        # Determine overall risk level
        if risk_score >= 20:
            risk_level = "CRITICAL"
        elif risk_score >= 10:
            risk_level = "HIGH"
        elif risk_score >= 5:
            risk_level = "MEDIUM"
        elif risk_score > 0:
            risk_level = "LOW"
        else:
            risk_level = "NONE"
        
        # Generate recommendations
        recommendations = self._generate_recommendations(vulnerabilities)
        
        # Prepare vulnerability details
        vulnerability_details = []
        for vuln in vulnerabilities:
            vulnerability_details.append({
                "id": vuln.id,
                "summary": vuln.summary,
                "severity": vuln.severity,
                "affected_module": vuln.affected_module,
                "affected_versions": vuln.affected_versions,
                "fixed_versions": vuln.fixed_versions,
                "cve_ids": vuln.cve_ids,
                "references": vuln.references
            })
        
        return {
            "scan_summary": {
                "total_modules": len(modules),
                "vulnerabilities_found": len(vulnerabilities),
                "risk_score": risk_score,
                "risk_level": risk_level,
                "scan_timestamp": datetime.now().isoformat()
            },
            "severity_breakdown": severity_counts,
            "vulnerabilities": vulnerability_details,
            "recommendations": recommendations,
            "affected_modules": list(set(v.affected_module for v in vulnerabilities)),
            "scan_details": {
                "direct_dependencies": len([m for m in modules if not m.indirect]),
                "indirect_dependencies": len([m for m in modules if m.indirect]),
                "scan_coverage": "go.mod analysis"
            }
        }
    
    def _generate_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Generate actionable recommendations based on vulnerabilities found."""
        recommendations = []
        
        if not vulnerabilities:
            recommendations.append("✅ No known vulnerabilities found in Go dependencies")
            recommendations.append("🔄 Consider running periodic security scans")
            recommendations.append("📋 Keep dependencies updated to latest stable versions")
            return recommendations
        
        # Critical vulnerabilities
        critical_vulns = [v for v in vulnerabilities if v.severity.upper() == "CRITICAL"]
        if critical_vulns:
            recommendations.append(f"🚨 URGENT: {len(critical_vulns)} critical vulnerabilities found - update immediately")
            for vuln in critical_vulns:
                if vuln.fixed_versions:
                    recommendations.append(f"   - Update {vuln.affected_module} to {vuln.fixed_versions[0]}")
        
        # High severity vulnerabilities
        high_vulns = [v for v in vulnerabilities if v.severity.upper() == "HIGH"]
        if high_vulns:
            recommendations.append(f"⚠️  {len(high_vulns)} high severity vulnerabilities require attention")
        
        # General recommendations
        affected_modules = set(v.affected_module for v in vulnerabilities)
        if affected_modules:
            recommendations.append(f"📦 Update the following modules: {', '.join(list(affected_modules)[:5])}")
        
        recommendations.append("🔧 Run 'go mod tidy' after updating dependencies")
        recommendations.append("🧪 Test thoroughly after security updates")
        recommendations.append("🔄 Set up automated dependency scanning in CI/CD")
        
        if len(vulnerabilities) > 5:
            recommendations.append("📊 Consider implementing a dependency management policy")
        
        return recommendations 